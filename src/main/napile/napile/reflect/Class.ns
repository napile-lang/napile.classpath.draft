package napile.reflect

import napile.reflect.Class
import napile.io.Console
import napile.annotation.Immutable

/**
 * @author VISTALL
 */
final class Class<E> : Member
{
	/**
	 * @return immutable array variables of class
	 */
	lazy val variables : @Immutable Array<Variable> = getVariables()

	/**
	 * @return immutable array constructors of class
	 */
	lazy val constructors : @Immutable Array<Constructor> = getConstructors()

	/**
	 * @return immutable array methods of class
	 */
	lazy val methods : @Immutable Array<Method> = getMethods()

	/**
	 * @return immutable array macros of class
	 */
	lazy val macros : @Immutable Array<Macro> = getMacros()

	/**
	 * @return super classes of this class
	 */
	lazy val superClasses : @Immutable Array<Class<Any>> = getSuperClasses()

	/**
	 * Main constructor of class. Access modifier is 'local'. Called only by VM
	 */
	local this(
			val owner : Class<Any>?,
			val name : String,
			val modifiers : Array<Modifier>,
			val annotations : Array<Any>) : Member(owner, name, modifiers, annotations)

	local native meth getVariables() : Array<Variable>

	local native meth getMacros() : Array<Macro>

	local native meth getMethods() : Array<Method>

	local native meth getConstructors() : Array<Constructor>

	local native meth getSuperClasses() : Array<Class<Any>>

	/**
	 * Searching method by name
	 */
	meth findMethod(val name : String, val parent : Bool) : Method?
	{
		for (m in methods)
			if (m.name.equals(name))
				return m

		if(parent)
			for(p in superClasses)
			{
				val m = findMethod(name, true)
				if(m != null)
					return m
			}
		return null;
	}
}